# Hello Future Coding Theory Researchers at Kenyon and Beyond

## I'm going to talk to you about the constacyclic partition algorithm.

Before you read this, you should have a general familiarity with the following topics:

- Cyclic Orders

- Cyclotomic Cosets

- Primitive Roots of Unity

- Basic Set Theory

- Finite/Galois Fields

I don't really have the inclination or ability to teach you these topics so please go ask someone smarter than me to teach them to you, like a professor or Sal Khan.

Okay, without further ado, here is the algorithm for constacyclic partitioning that can be found in the file newtemplate.txt:

1. Start with a length *n*, a field *q*, and a shift constant *a*.

2. Calculate *r*, the order of *a* in *GF(q)*, and *p*, the characteristic of *GF(q)*.

3. Write *n* in the form *n'p^t* such that *n'* is not divisible by *p*. Basically, you want to take *p* out of *n* as many times as possible.

4. Generate cyclotomic cosets of *q mod n'r*.

5. From the cosets you generated in part 4, we're going to pick out the cosets whose numbers are in the list generated by *1 + ir*, for *i in {0,1,...,n-1}*. By mathematical magic, and coset which contains at least one *1 + ir* number will only contain *1 + ir* numbers. In implementation, we can shortcut this by simply starting with the *1 + ir* set and generating cosets from there.

6. Now you're going to want to make combinations of cosets. You basically want to generate every possible combination of cosets possible, taking any one coset between 0 and *p^t* times. For example, if we had cosets {1} and {2,4,5}, and *p^t* was 2, we would generate the following combinations: {},{1},{2,4,5},{1,2,4,5},{1,1},{2,2,4,4,5,5},{1,1,2,2,4,4,5,5}.

7. Check for linear maps between the different sets. Basically, you want to see if there exists some function *ax+b* that's a one to one correspondence between sets. For example, there is a map between {0,2,3} and {1,5,7} since the formula 2x+1 takes 0 -> 1, 2 -> 5 and 3 -> 7. However, note that there is no map between {0,2,3} and {1,1,5,5,7,7}, since this is onto but not one to one. This step is where the equivalency comes in -- if two sets have a map between them, we only keep one. This leaves us with one set from each equivalence class.

8. Find the primitive *n'r*-th root of unity over *GF(q)*, which we call *beta* or just *b*.

9. Now we take our sets left over from step 7 and turn them into polynomials. For each member of a set, k, turn it into *(x-b^k)*, then multiply each member of the set. For example, {1,4,5} becomes *(x-b^1)(x-b^4)(x-b^5)*.

10. Now you have a set of polynomials, each of which generate a constacyclic code. Note that it is still possible that some of them produce equivalent codes. However, it's guaranteed that any codes eliminated in step 7 were equivalent to one that you generated.
